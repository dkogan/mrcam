#!/usr/bin/env python3

r'''Report image sharpness over time

SYNOPSIS

  $ ./focus

  [ Interactive window up pop up showing the realtime view; clicking on the ]
  [ image shows a realtime plot of the sharpness in those areas             ]

This tool is intended to automate camera-focussing procedures. It repeatedly
grabs images, and plots a "sharpness" metric in each region of interest. The
user moves the focus ring, while looking at the realtime feedback displayed by
this tool.

'''


import sys
import argparse
import re
import os

def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('--verbose',
                        action='store_true',
                        help='''If given, we turn on mrcam verbose reporting.
                        This is separate from the deeper diagnostics provided by
                        aravis using the ARV_DEBUG environment variable. See the
                        aravis documentation for those details''')

    parser.add_argument('--period',
                        type=float,
                        default = 1.0,
                        help='''Image capture period, in seconds. Defaults to
                        1.0sec/frame''')

    parser.add_argument('--single-buffered',
                        action='store_true',
                        help='''By default the image display is double-buffered
                        to avoid flickering. Some graphics hardare (in
                        particular my old i915-based system) are buggy, and
                        don't work right in this mode, so --single-buffered is
                        available to disable double-buffering to work around
                        those bugs''')




    parser.add_argument('--radius',
                        type=int,
                        default = 50,
                        help='''The radius of the boxes that define the focusing
                        region-of-interest. If omitted, defaults to 50 pixels''')
    parser.add_argument('--plot-history',
                        type=float,
                        default = 30,
                        help='''The width of the sharpness plot. If omitted,
                        defaults to 30 seconds''')



    parser.add_argument('camera',
                        type = str,
                        nargs = '?',
                        default = '',
                        help='''The camera to talk to. This is a string passed
                        to the arv_camera_new() function; see that function's
                        documentation for details. The string can be IP
                        addresses or MAC addresses or vendor-model-serialnumber
                        strings. If omitted, we take the first available camera''')

    args = parser.parse_args()

    return args


args = parse_args()

import numpy as np
import numpysane as nps
import cv2
from fltk import *
from Fl_Gl_Image_Widget import *
from Fl_gnuplotlib import *

import mrcam


focus_regions = []
imagersize = None
t = 0





# from "gnuplot -e 'show linetype'"
color_sequence_rgb = (
    "0x9400d3",
    "0x009e73",
    "0x56b4e9",
    "0xe69f00",
    "0xf0e442",
    "0x0072b2",
    "0xe51e10",
    "0x000000"
)

def color_array_from_string(c):
    x = int(c, 0)

    r = (x >> 16) & 255
    g = (x >>  8) & 255
    b = (x >>  0) & 255
    return np.array((r,g,b), dtype=np.float32) / 255.

def sharpness(image):
    '''Reports a measure of sharpness in an image.

    There're many ways to do this. I look at this:

        Said Pertuz, Domenec Puig, Miguel Angel Garcia, "Analysis of focus
        measure operators for shape-from-focus", Pattern Recognition Volume 46,
        Isue 5, May 2013.

    They looked at a bunch of operators, and there wasn't a standout. I use the
    basic norm2(laplacian) since it's simple, and they had decent results with
    it. This is LAP1 described in section A.17.

    '''

    # image may be high-depth and it may be in color
    if image.ndim == 3:
        image = nps.mag( image.astype(np.float32) )
    elif image.ndim == 2:
        image = image.astype(np.float32)
    else:
        raise Exception(f"image.shape must be 2 or 3; dont't know what to do with {image.shape=}")

    L = cv2.Laplacian(image,
                      ddepth = cv2.CV_32F,
                      borderType = cv2.BORDER_REFLECT)
    return nps.norm2(L.ravel())

def update_sharpness(image):
    global t
    global imagersize
    if imagersize is None:
        imagersize = np.array((image.shape[1], image.shape[0]),)

    for region in focus_regions:
        roi  = region['roi']
        region['data'] = nps.glue(region['data'],
                                  np.array((t, sharpness(image[roi[0],roi[1]])),
                                           dtype=float),
                                  axis = -2)

    if focus_regions:
        plot_widget.plot(*[(region['data'] - np.array((t,0),),
                            dict(tuplesize = -2,
                                 _with     = f"lines lw 2 lc \"{region['color_string']}\"")) \
                           for region in focus_regions])

    t += args.period




class Fl_Gl_Image_Widget_Derived(Fl_Gl_Image_Widget):
    def handle(self, event):
        if event != FL_PUSH:
            return super().handle(event)

        if Fl.event_button() != FL_RIGHT_MOUSE:
            return super().handle(event)

        try:
            q = np.round(np.array(self.map_pixel_image_from_viewport( (Fl.event_x(),Fl.event_y()), ))).astype(int)
        except:
            return super().handle(event)

        if q is None:
            return super().handle(event)



        global focus_regions
        global imagersize

        q00 = q - args.radius
        q11 = q + args.radius

        if imagersize is None             or \
           np.any(q00 < 0)                or \
           np.any(q11 < 0)                or \
           np.any(imagersize-1 - q00 < 0) or \
           np.any(imagersize-1 - q11 < 0):
            return super().handle(event)


        # New region
        focus_regions.append(dict())
        region = focus_regions[-1]

        region['roi'] = ( slice(q00[1],q11[1]),
                          slice(q00[0],q11[0]) )
        q01 = np.array((q00[0], q11[1]))
        q10 = np.array((q11[0], q00[1]))

        color_string = color_sequence_rgb[ (len(focus_regions)-1) %
                                          len(color_sequence_rgb)]
        color_array = color_array_from_string(color_string)
        region_marking = dict(points = nps.cat(nps.cat(q00,q01),
                                               nps.cat(q01,q11),
                                               nps.cat(q11,q10),
                                               nps.cat(q10,q00)).astype(np.float32),
                              color_rgb = color_array )
        region['region_marking'] = region_marking
        region['color_string']   = color_string
        self.set_lines( *[r['region_marking'] for r in focus_regions] )

        region['data'] = np.array(())

        return super().handle(event)


window        = Fl_Window(800, 600, "mrcam focus tool")
image_widget  = Fl_Gl_Image_Widget_Derived(0,  0, 400,600,
                                           double_buffered = not args.single_buffered)
plot_widget   = Fl_Gnuplotlib_Window      (400, 0, 400,600,
                                           ymin = 0,
                                           _xrange=(-args.plot_history,0)
                                           )
window.resizable(window)
window.end()
window.show()


# try block needed to avoid potential crashes:
#   https://sourceforge.net/p/pyfltk/mailman/pyfltk-user/thread/875xx5ncgp.fsf%40secretsauce.net/#msg58754407
try:
    c = mrcam.camera(args.camera,
                     verbose = args.verbose)
except Exception as e:
    window.hide()
    raise e






def callback_image_ready(fd):
    frame = c.requested_image()

    image        = frame['image']
    timestamp_us = frame['timestamp_us']

    if image is not None:
        # Update the image preview; deep images are shown as a heat map
        if image.itemsize > 1:
            if image.ndim > 2:
                raise Exception("high-depth color images not supported yet")
            image_widget.update_image(image_data = mrcal.apply_color_map(image))
        else:
            image_widget.update_image(image_data = image)

        update_sharpness(image)

    else:
        print("Error capturing the image. I will try again",
              file=sys.stderr)

    Fl.add_timeout(args.period, update)

def update(*args):

    # try block needed to avoid potential crashes:
    #   https://sourceforge.net/p/pyfltk/mailman/pyfltk-user/thread/875xx5ncgp.fsf%40secretsauce.net/#msg58754407
    try:
        c.request()
    except Exception as e:
        window.hide()
        raise e




Fl.add_fd( c.fd_image_ready,
           callback_image_ready )

update()
Fl.run()
