#!/usr/bin/python3


r'''mrcam camera preview tool

SYNOPSIS

  $ mrcam

  [ A window pops up showing a live view of the first available camera ]

This tool provides the most basic camera tools: an image preview with some
rudimentary image capture and parameter control

'''


import sys
import argparse
import re
import os

import mrcam

def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)

    mrcam._add_common_cmd_options(parser,
                                  single_camera = False)

    args = parser.parse_args()

    mrcam._parse_args_postprocess(args)

    return args


args = parse_args()


from fltk import *
import math
import mrcal

file_log = None
def write_logline(l):
    global file_log

    def write(f,l):
        print(l,file=f)
        f.flush()

    if file_log is not None:
        write(file_log,l)
    write(sys.stdout, l)


def request_image_set():
    global image_view_groups
    for image_view_group in image_view_groups:
        image_view_group.camera.request()

Ncameras_seen_this_frame = 0
iframe_this              = -1
def image_callback(image,
                   *,
                   timestamp_us,
                   iframe,
                   icam,
                   logdir,
                   extension):

    global Ncameras_seen_this_frame
    global iframe_this

    if logdir is not None:
        # write image to disk
        filename = f"frame{iframe:05d}-cam{icam}.{extension}"
        path = f"{logdir}/{filename}"

        if image is None:
            write_logline(f"{timestamp_us/1e6:.3f} {iframe} {icam} -");
        else:
            mrcal.save_image(path, image)
            write_logline(f"{timestamp_us/1e6:.3f} {iframe} {icam} {filename}");


    # schedule the next set of images
    if iframe_this != iframe:
        iframe_this = iframe
        Ncameras_seen_this_frame = 0
    Ncameras_seen_this_frame += 1
    if Ncameras_seen_this_frame == Ncameras:
        # Every camera reported back. Ask for another frame
        mrcam.schedule_next_frame(request_image_set, args.period)

kwargs = dict()
if args.dims is not None:
    kwargs['width' ] = args.dims[0]
    kwargs['height'] = args.dims[1]
if args.pixfmt is not None:
    kwargs['pixfmt'] = args.pixfmt
if args.trigger is not None:
    kwargs['trigger'] = args.trigger

Ncameras = len(args.camera)
cameras           = [None] * Ncameras
image_view_groups = [None] * Ncameras

# I init each camera. If we're doing serial triggering, only the LAST camera
# should touch these: it's assumed that the trigger and power signals are shared
# between ALL the cameras. I give this to the last camera and not the first, so
# that at capture time all the cameras get ready to capture, and only then do we
# actually send the trigger; otherwise when the first camera sends the trigger,
# the last camera might still be initializing
if not args.replay:
    for i,camera in reversed(list(enumerate(args.camera))):
        cameras[i] = \
            mrcam.camera(camera,
                         verbose = args.verbose,
                         recreate_stream_with_each_frame = args.recreate_stream_with_each_frame,
                         **kwargs)

        if kwargs['trigger'] == 'TTYS0':
            kwargs['trigger'] = 'HARDWARE_EXTERNAL'


    if args.logdir is not None:
        path = f"{args.logdir}/images.vnl"
        try:
            file_log = open(path, "w")
        except Exception as e:
            print(f"Error opening log file '{path}' for writing: {e}",
                  file=sys.stderr)
            sys.exit(1)

        for i,c in enumerate(args.camera):
            print(f"## Camera {i}: {c}", file=file_log)
        write_logline("# time iframe icam imagepath");

else:
    # We're replaying a log

    # I need at least vnlog 1.38 to support structured dtypes in vnlog.slurp().
    # See
    #   https://notes.secretsauce.net/notes/2024/07/02_vnlogslurp-with-non-numerical-data.html
    import vnlog
    import numpy as np
    import numpysane as nps

    path = f"{args.logdir}/images.vnl"
    max_len_imagepath = 128

    dtype = np.dtype([ ('time',      float),
                       ('iframe',    np.int32),
                       ('icam',      np.int8),
                       ('imagepath', f'U{max_len_imagepath}'),
                      ])
    log = vnlog.slurp(path, dtype=dtype)

    # I have the whole log. I cut it down to include ONLY the cameras that were
    # requested
    i = np.min( np.abs(nps.dummy(np.array(args.camera), -1) - \
                       log['icam']),
                axis=-2) == 0
    log = log[i]

    if log.size == 0:
        print(f"The requested cameras {args.camera=} don't have any data in the log {path}",
              file = sys.stderr)
        sys.exit(1)

    if max(len(s) for s in log['imagepath']) >= max_len_imagepath:
        print(f"Image paths in {path} are longer than the statically-defined value of {max_len_imagepath=}. Increase max_len_imagepath, or make the code more general", file=sys.stderr)
        sys.exit(1)

    # While the tool is running I want to be able to access the images in O(1),
    # so I pre-sort the log now to make that possible. For each constant iframe
    # I want a monotonically-increasing icam
    log = np.sort(log, order=('iframe','icam'))

    # I should have dense data over frames and cameras. I try to reshape it in
    # that way, and confirm that everything lines up
    Nframes  = len(log) // Ncameras
    if Nframes*Ncameras != len(log):
        print(f"The log {path} does not contain all dense combinations of {Ncameras=} and {Nframes=}. For the requested cameras it has {len(log)} entries",
              file = sys.stderr)
        for icam in args.camera:
            print(f"  Requested camera {icam} has {np.count_nonzero(log['icam']==icam)} observed frames",
                  file = sys.stderr)
        print("These should all be idendical",
              file=sys.stderr)
        sys.exit(1)

    log = log.reshape((Nframes,Ncameras))
    if np.any(log['icam'] - log['icam'][0,:]):
        print(f"The log {path} does not contain the same set of cameras in each frame",
              file = sys.stderr)
        sys.exit(1)
    if np.any( np.sort(args.camera) - log['icam'][0,:] ):
        print(f"The log {path} does not contain exactly the cameras requested in {args.camera=}",
              file = sys.stderr)
        sys.exit(1)
    if np.any(log['iframe'] - log['iframe'][:,(0,)]):
        print(f"The log {path} does not contain the same set of frames observing each camera",
              file = sys.stderr)
        sys.exit(1)

    # Great. We have a dense set




W        = 800
H        = 600
H_footer = 20 # we might have more than one of these

window = Fl_Window(W,H, "mrcam stream")


H_status      = H_footer
H_time_slider = H_footer
H_footers = (H_status + H_time_slider)

Ngrid = math.ceil(math.sqrt(Ncameras))
Wgrid = Ngrid
Hgrid = math.ceil(Ncameras/Wgrid)

w_image    = W             // Wgrid
h_image    = (H-H_footers) // Hgrid
icam = 0
y0   = 0

if args.replay:

    def time_slider_select(i_iframe):
        global image_view_groups

        record = log[i_iframe,:]

        # shape (Ncameras,); all of these
        times = record['time']
        paths = record['imagepath']

        for i_icam in range(Ncameras):
            if args.image_path_prefix is not None:
                path = f"{args.image_path_prefix}/{paths[i_icam]}"
            elif args.image_directory is not None:
                path = f"{args.image_directory}/{os.path.basename(paths[i_icam])}"
            elif paths[i_icam][0] != '/':
                # The image filename has a relative path. I want it to be
                # relative to the log directory
                path = f"{args.logdir}/{paths[i_icam]}"

            try:
                image = mrcal.load_image(path)
            except:
                print(f"Couldn't read image at '{path}'", file=sys.stderr)
                sys.exit(1)

            image_view_groups[i_icam].update_image_widget( image,
                                                           flip_x = args.flip_x,
                                                           flip_y = args.flip_y)

    time_slider_widget = \
        Fl_Slider(0, H-H_footers,
                  W,H_time_slider)
    time_slider_widget.align(FL_ALIGN_BOTTOM)
    time_slider_widget.type(FL_HORIZONTAL)
    time_slider_widget.step(1)
    time_slider_widget.callback( lambda *args: time_slider_select(round(time_slider_widget.value())) )
    time_slider_widget.value(0)
    time_slider_widget.bounds(0, Nframes-1)

status_widget = Fl_Output(0, H-H_status,
                          W, H_status)
status_widget.value('')

image_views = Fl_Group(0, 0, W, H-H_footers)
for i in range(Hgrid):
    x0 = 0

    for j in range(Wgrid):
        image_view_groups[icam] = \
            mrcam.Fl_Image_View_Group(x0,y0,
                                      w_image if j < Wgrid-1 else (W          -x0),
                                      h_image if i < Hgrid-1 else (H-H_footers-y0),
                                      camera          = cameras[icam],
                                      single_buffered = args.single_buffered,
                                      status_widget   = status_widget,
                                      feature_names   = args.features)
        image_view_groups[icam].set_up_image_capture(period         = None, # don't auto-recur. I do that myself, making sure ALL the cameras are processed
                                                     image_callback = image_callback,
                                                     extension      = "jpg" if args.jpg else "png",
                                                     logdir         = args.logdir,
                                                     icam           = icam,
                                                     flip_x         = args.flip_x,
                                                     flip_y         = args.flip_y)


        x0   += w_image
        icam += 1

        if icam == Ncameras:
            break
    if icam == Ncameras:
        break

    y0 += h_image
image_views.end()

window.resizable(image_views)
window.end()
window.show()

if not args.replay:
    # request the initial frame; will recur in image_callback
    request_image_set()

Fl.run()
