#!/usr/bin/python3


r'''mrcam camera preview tool

SYNOPSIS

  $ mrcam

  [ A window pops up showing a live view of the first available camera ]

This tool provides the most basic camera tools: an image preview with some
rudimentary image capture and parameter control

'''


import sys
import argparse
import re
import os

import mrcam

def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)

    mrcam._add_common_cmd_options(parser,
                                  single_camera = False)

    parser.add_argument('--outdir',
                        help='''The output directory to write images to. If
                        omitted, we do NOT write any output images to disk; we
                        just display them as they come in''')
    parser.add_argument('--jpg',
                        action='store_true',
                        help='''If given, we write the output images as .jpg
                        files, using lossy compression. If omitted, we write out
                        lossless .png files (bigger, much slower to compress,
                        decompress). Some pixel formats (deep ones, in
                        particular) do not work with.jpg''')

    args = parser.parse_args()

    mrcam._parse_args_postprocess(args)

    return args


args = parse_args()

if args.power_cycle_at_startup or \
   args.power_down_when_finished:
    if args.trigger != 'TTYS0':
        print("Power control is only available with '--trigger TTYS0'",
              file = sys.stderr)
        sys.exit(1)


from fltk import *
import math
import mrcal

def request_image_set():
    global image_view_groups
    for image_view_group in image_view_groups:
        image_view_group.camera.request()

Ncameras_seen_this_frame = 0
iframe_this              = -1
def image_callback(image,
                   *,
                   timestamp_us,
                   iframe,
                   icam,
                   outdir,
                   extension):

    global Ncameras_seen_this_frame
    global iframe_this

    if args.outdir is not None:
        # write image to disk
        path = f"{outdir}/frame{iframe:05d}-cam{icam}.{extension}"

        if image is None:
            print(f"{timestamp_us/1e6:.3f} {iframe} {icam} -");
        else:
            mrcal.save_image(path, image)
            print(f"{timestamp_us/1e6:.3f} {iframe} {icam} {path}");
        sys.stdout.flush()


    # schedule the next set of images
    if iframe_this != iframe:
        iframe_this = iframe
        Ncameras_seen_this_frame = 0
    Ncameras_seen_this_frame += 1
    if Ncameras_seen_this_frame == Ncameras:
        # Every camera reported back. Ask for another frame
        mrcam._schedule_next_frame(request_image_set, args.period)

kwargs = dict()
if args.dims is not None:
    kwargs['width' ] = args.dims[0]
    kwargs['height'] = args.dims[1]
if args.pixfmt is not None:
    kwargs['pixfmt'] = args.pixfmt
if args.trigger is not None:
    kwargs['trigger'] = args.trigger

Ncameras = len(args.camera)
cameras           = [None] * Ncameras
image_view_groups = [None] * Ncameras

# I init each camera. If we're doing serial triggering and power control, only
# the LAST camera should touch these: it's assumed that the trigger and power
# signals are shared between ALL the cameras. I give this to the last camera and
# not the first, so that at capture time all the cameras get ready to capture,
# and only then do we actually send the trigger; otherwise when the first camera
# sends the trigger, the last camera might still be initializing
for i,camera in reversed(list(enumerate(args.camera))):
    cameras[i] = \
        mrcam.camera(camera,
                     verbose = args.verbose,
                     recreate_stream_with_each_frame = args.recreate_stream_with_each_frame,
                     power_cycle_at_startup          = args.power_cycle_at_startup,
                     power_down_when_finished        = args.power_down_when_finished,
                     **kwargs)

    if kwargs['trigger'] == 'TTYS0':
        args.power_cycle_at_startup   = False
        args.power_down_when_finished = False
        kwargs['trigger']             = 'HARDWARE_EXTERNAL'


if args.outdir is not None:
    print("# time iframe icam imagepath");


W        = 800
H        = 600
H_status = 20

window = Fl_Window(W,H, "mrcam stream")


Ngrid = math.ceil(math.sqrt(Ncameras))
Wgrid = Ngrid
Hgrid = math.ceil(Ncameras/Wgrid)

w    = W           //Wgrid
h    = (H-H_status)//Hgrid
icam = 0
y0   = 0

status_widget = Fl_Output(0, H-H_status, W, H_status)
status_widget.value('')

image_views = Fl_Group(0, 0, W, H-H_status)
for i in range(Hgrid):
    x0 = 0

    for j in range(Wgrid):
        image_view_groups[icam] = \
            mrcam.Fl_Image_View_Group(x0,y0,
                                      w if j < Wgrid-1 else (W         -x0),
                                      h if i < Hgrid-1 else (H-H_status-y0),
                                      camera          = cameras[icam],
                                      single_buffered = args.single_buffered,
                                      status_widget   = status_widget,
                                      feature_names   = args.features)
        image_view_groups[icam].set_up_image_capture(period         = None, # don't auto-recur. I do that myself, making sure ALL the cameras are processed
                                                     image_callback = image_callback,
                                                     extension      = "jpg" if args.jpg else "png",
                                                     outdir         = args.outdir,
                                                     icam           = icam,
                                                     flip_x         = 'x' in args.display_flip,
                                                     flip_y         = 'y' in args.display_flip)


        x0   += w
        icam += 1

        if icam == Ncameras:
            break
    if icam == Ncameras:
        break

    y0 += h
image_views.end()

window.resizable(image_views)
window.end()
window.show()

# request the initial frame; will recur in image_callback
request_image_set()

Fl.run()
