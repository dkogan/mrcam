#!/usr/bin/python3


r'''mrcam camera preview tool

SYNOPSIS

  $ mrcam

  [ A window pops up showing a live view of the first available camera ]

This tool provides the most basic camera tools: a live image view and/or a log
replay with feature controls.

'''


import sys
import argparse
import re
import os

import mrcam

def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)

    mrcam._add_common_cmd_options(parser,
                                  single_camera = False)

    parser.add_argument('--logdir',
                        help='''The directory to write the images and
                        metadata. If omitted, we do NOT log anything to
                        disk. Exclusive with --replay. When logging,
                        simultaneous replaying is ALWAYS enabled''')
    parser.add_argument('--jpg',
                        action='store_true',
                        help='''If given, we write the output images as .jpg
                        files, using lossy compression. If omitted, we write out
                        lossless .png files (bigger, much slower to compress,
                        decompress). Some pixel formats (deep ones, in
                        particular) do not work with.jpg''')

    parser.add_argument('--replay',
                        help='''If given, we replay the stored images
                        instead of talking to camera hardware. The log
                        directory must be given as an argument to --replay.
                        Exclusive with --logdir.''')
    parser.add_argument('--replay-from-frame',
                        type=int,
                        default=0,
                        help='''If given, we start the replay at the given
                        frame, instead of at the start of the log''')
    parser.add_argument('--image-path-prefix',
                        help='''Used with --replay. If given, we prepend the
                        given prefix to the image paths in the log. Exclusive
                        with --image-directory''')
    parser.add_argument('--image-directory',
                        help='''Used with --replay. If given, we extract the
                        filenames from the image paths in the log, and use the
                        given directory to find those filenames. Exclusive with
                        --image-path-prefix''')
    parser.add_argument('--timezone-offset-hours',
                        default=0,
                        type=float,
                        help='''Used with --replay to determine the mapping
                        between the UNIX timestamps in the log file (in UTC) and
                        local time. Given in hours. For instance, Pacific
                        Standard Time is UTC-08:00, so pass
                        --timezone-offset-hours -8. If omitted, we default to
                        UTC''')


    args = parser.parse_args()

    mrcam._parse_args_postprocess(args)


    if args.replay is not None and \
       args.logdir is not None:
        print("--replay and --logdir are mutually exclusive",
              file=sys.stderr)
        sys.exit(1)



    if args.replay is not None:
        def camera_for_replay(s):
            if s is None:
                return [0]

            try:
                i = int(s)
                if i < 0:
                    print(f"--replay given, so the cameras must be a list of non-negative integers and/or A-B ranges. Invalid camera given: '{s}'",
                          file=sys.stderr)
                    sys.exit(1)
                return [i]
            except Exception as e:
                pass

            m = re.match("^([0-9]+)-([0-9]+)$", s)
            if m is None:
                print(f"--replay given, so the cameras must be a list of non-negative integers and/or A-B ranges. Invalid camera given: '{s}'",
                      file=sys.stderr)
                sys.exit(1)
            try:
                i0 = int(m.group(1))
                i1 = int(m.group(2))
            except Exception as e:
                print(f"--replay given, so the cameras must be a list of non-negative integers and/or A-B ranges. Invalid camera given: '{s}'",
                      file=sys.stderr)
                sys.exit(1)
            return list(range(i0,i1+1))


        if args.camera is None:
            # one camera; unspecified
            args.camera = 0
        elif isinstance(args.camera, str):
            # one camera; parse as int > 0
            try:
                args.camera = int(args.camera)
            except:
                print(f"--replay given, so the camera must be an integer >= 0",
                      file=sys.stderr)
                sys.exit(1)
            if args.camera < 0:
                print(f"--replay given, so the camera must be an integer >= 0",
                      file=sys.stderr)
                sys.exit(1)
        else:
            # multiple cameras
            args.camera = [c for cam in args.camera for c in camera_for_replay(cam)]

    if args.features is not None and \
       args.replay   is not None:
        print("--replay and --features are mutually exclusive",
              file=sys.stderr)
        sys.exit(1)

    return args


args = parse_args()


from fltk import *
import math
import mrcal
import datetime


file_log           = None
log_replay         = []
time_slider_widget = None

def write_logline(l):
    global file_log

    if file_log is not None:
        print(l,file=file_log)
        file_log.flush()


def request_image_set():
    global image_view_groups
    for image_view_group in image_view_groups:
        image_view_group.camera.request()

Ncameras_seen_this_frame = 0
iframe_this              = -1
def image_callback(image,
                   *,
                   timestamp_us,
                   iframe,
                   # All these are th cookie given to set_up_image_capture()
                   icam,
                   logdir,
                   extension):

    global Ncameras_seen_this_frame
    global iframe_this

    if iframe_this != iframe:
        iframe_this = iframe
        Ncameras_seen_this_frame = 0

    if logdir is None:

        image_view_groups[icam].update_image_widget( image  = image,
                                                     flip_x = args.flip_x,
                                                     flip_y = args.flip_y )
    else:

        if Ncameras_seen_this_frame == 0:
            # Started this set of cameras. Add empty record; fill it in as I get
            # frames
            log_replay.append( dict(time      = [None] * Ncameras,
                                    imagepath = [None] * Ncameras,
                                    iframe    = [None] * Ncameras) )


        timestamp_s = timestamp_us / 1e6

        # write image to disk
        filename = f"frame{iframe:05d}-cam{icam}.{extension}"
        path = f"{logdir}/{filename}"

        if image is None:
            write_logline(f"{timestamp_s:.3f} {iframe} {icam} -");
        else:
            mrcal.save_image(path, image)
            write_logline(f"{timestamp_s:.3f} {iframe} {icam} {filename}");

        time_slider_now = int(time_slider_widget.value())
        time_slider_at_max = \
            time_slider_now == int(time_slider_widget.maximum())

        if time_slider_at_max:
            image_view_groups[icam].update_image_widget( image  = image,
                                                         flip_x = args.flip_x,
                                                         flip_y = args.flip_y )

        log_replay[-1]['time'     ][icam] = timestamp_s
        log_replay[-1]['iframe'   ][icam] = iframe
        if image is not None:
            log_replay[-1]['imagepath'][icam] = path
            # Otherwise, leave at None

    # schedule the next set of images
    Ncameras_seen_this_frame += 1
    if Ncameras_seen_this_frame == Ncameras:
        # Every camera reported back. Finish up and ask for another frame

        if time_slider_widget is not None:
            time_slider_widget.maximum(iframe)

            if time_slider_at_max:
                time_slider_widget.value(iframe)
                time_slider_update_label(iframe, timestamp_s)
            else:
                time_slider_update_label(time_slider_now, timestamp_s)
                # The bounds changed, so the handle should be redrawn
                time_slider_widget.redraw()

        mrcam.schedule_next_frame(request_image_set, args.period)



def complete_path(path):

    if path is None:
        return None

    if args.logdir is not None:
        # We're logging; we already have the full path
        return path

    if args.image_path_prefix is not None:
        return f"{args.image_path_prefix}/{path}"
    if args.image_directory is not None:
        return f"{args.image_directory}/{os.path.basename(path)}"
    if path[0] != '/':
        # The image filename has a relative path. I want it to be
        # relative to the log directory
        return f"{args.logdir}/{path}"

    return path


def update_image_from_path(icam, path):
    if path is None:
        print("WARNING: need to write a black image to the GL_image_display, but it doesn't have that function yet. Leaving the stale image")
        return

    try:
        image = mrcal.load_image(path)
    except:
        print(f"Couldn't read image at '{path}'", file=sys.stderr)
        sys.exit(1)

    image_view_groups[icam].update_image_widget( image,
                                                 flip_x = args.flip_x,
                                                 flip_y = args.flip_y)

def time_slider_update_label(iframe,time):
    t = int(time + args.timezone_offset_hours*3600.)
    t = datetime.datetime.fromtimestamp(t, datetime.UTC)
    time_slider_widget.label(f"iframe={iframe}/{int(time_slider_widget.maximum())} timestamp={time:.03f} {t.strftime('%Y-%m-%d %H:%M:%S')}{' UTC' if args.timezone_offset_hours==0 else ''}")

def time_slider_select(i_iframe):
    global image_view_groups
    global log_replay

    record = log_replay[i_iframe]

    # shape (Ncameras,); all of these
    times   = record['time']
    paths   = record['imagepath']
    iframes = record['iframe']

    time_slider_update_label(iframes[0], times[0])

    for icam in range(Ncameras):
        update_image_from_path(icam, complete_path(paths[icam]))


def open_log(logdir,
             camera,
             replay_from_frame):
    # I need at least vnlog 1.38 to support structured dtypes in vnlog.slurp().
    # See
    #   https://notes.secretsauce.net/notes/2024/07/02_vnlogslurp-with-non-numerical-data.html
    import vnlog
    import numpy as np
    import numpysane as nps

    path = f"{logdir}/images.vnl"
    max_len_imagepath = 128

    dtype = np.dtype([ ('time',      float),
                       ('iframe',    np.int32),
                       ('icam',      np.int8),
                       ('imagepath', f'U{max_len_imagepath}'),
                      ])
    log = vnlog.slurp(path, dtype=dtype)

    # I have the whole log. I cut it down to include ONLY the cameras that were
    # requested
    i = np.min( np.abs(nps.dummy(np.array(camera), -1) - \
                       log['icam']),
                axis=-2) == 0
    log = log[i]

    if log.size == 0:
        print(f"The requested cameras {camera=} don't have any data in the log {path}",
              file = sys.stderr)
        sys.exit(1)

    if max(len(s) for s in log['imagepath']) >= max_len_imagepath:
        print(f"Image paths in {path} are longer than the statically-defined value of {max_len_imagepath=}. Increase max_len_imagepath, or make the code more general", file=sys.stderr)
        sys.exit(1)

    # While the tool is running I want to be able to access the images in O(1),
    # so I pre-sort the log now to make that possible. For each constant iframe
    # I want a monotonically-increasing icam
    log = np.sort(log, order=('iframe','icam'))

    # I should have dense data over frames and cameras. I try to reshape it in
    # that way, and confirm that everything lines up
    Nframes  = len(log) // Ncameras
    if Nframes*Ncameras != len(log):
        print(f"The log {path} does not contain all dense combinations of {Ncameras=} and {Nframes=}. For the requested cameras it has {len(log)} entries",
              file = sys.stderr)
        for icam in camera:
            print(f"  Requested camera {icam} has {np.count_nonzero(log['icam']==icam)} observed frames",
                  file = sys.stderr)
        print("These should all be idendical",
              file=sys.stderr)
        sys.exit(1)

    if not (replay_from_frame >= 0 and \
            replay_from_frame < Nframes):
        print(f"We have {Nframes=} in the log '{path}', so --replay-from-frame must be in [0,{Nframes-1}], but we have --replay-from-frames {replay_from_frame}",
              file = sys.stderr)
        sys.exit(1)

    log = log.reshape((Nframes,Ncameras))
    if np.any(log['icam'] - log['icam'][0,:]):
        print(f"The log {path} does not contain the same set of cameras in each frame",
              file = sys.stderr)
        sys.exit(1)
    if np.any( np.sort(camera) - log['icam'][0,:] ):
        print(f"The log {path} does not contain exactly the cameras requested in {camera=}",
              file = sys.stderr)
        sys.exit(1)
    if np.any(log['iframe'] - log['iframe'][:,(0,)]):
        print(f"The log {path} does not contain the same set of frames observing each camera",
              file = sys.stderr)
        sys.exit(1)

    # Great. We have a dense set. We're done!
    return log





kwargs = dict()
if args.dims is not None:
    kwargs['width' ] = args.dims[0]
    kwargs['height'] = args.dims[1]
if args.pixfmt is not None:
    kwargs['pixfmt'] = args.pixfmt
if args.trigger is not None:
    kwargs['trigger'] = args.trigger

Ncameras = len(args.camera)
cameras           = [None] * Ncameras
image_view_groups = [None] * Ncameras

# I init each camera. If we're doing serial triggering, only the LAST camera
# should touch these: it's assumed that the trigger and power signals are shared
# between ALL the cameras. I give this to the last camera and not the first, so
# that at capture time all the cameras get ready to capture, and only then do we
# actually send the trigger; otherwise when the first camera sends the trigger,
# the last camera might still be initializing
if args.replay is None:
    for i,camera in reversed(list(enumerate(args.camera))):
        cameras[i] = \
            mrcam.camera(camera,
                         verbose = args.verbose,
                         recreate_stream_with_each_frame = args.recreate_stream_with_each_frame,
                         **kwargs)

        if kwargs['trigger'] == 'TTYS0':
            # As noted above, if we're generating a trigger signal, the LAST
            # camera only should do that. So here the non-last cameras are set
            # to expect a trigger signal, but not to produce it
            kwargs['trigger'] = 'HARDWARE_EXTERNAL'


    if args.logdir is not None:
        path = f"{args.logdir}/images.vnl"
        try:
            file_log = open(path, "w")
        except Exception as e:
            print(f"Error opening log file '{path}' for writing: {e}",
                  file=sys.stderr)
            sys.exit(1)

        for i,c in enumerate(args.camera):
            if c is not None:
                print(f"## Camera {i}: {c}", file=file_log)
        write_logline("# time iframe icam imagepath");

else:
    # We're replaying a log
    log_replay = \
        open_log(args.replay,
                 args.camera,
                 args.replay_from_frame)



W        = 1280
H        = 1024
H_footer = 30 # we might have more than one of these

window = Fl_Window(W,H, "mrcam stream")

have_time_slider = \
    args.replay is not None or \
    args.logdir is not None


H_status                  = H_footer
H_time_slider             = H_footer
H_time_slider_with_labels = H_time_slider + H_footer
H_footers                 = H_status
if have_time_slider:
    H_footers += H_time_slider_with_labels

Ngrid = math.ceil(math.sqrt(Ncameras))
Wgrid = Ngrid
Hgrid = math.ceil(Ncameras/Wgrid)

w_image    = W             // Wgrid
h_image    = (H-H_footers) // Hgrid
icam = 0
y0   = 0

if have_time_slider:
    time_slider_widget = \
        Fl_Slider(0, H-H_footers,
                  W,H_time_slider)
    time_slider_widget.align(FL_ALIGN_BOTTOM)
    time_slider_widget.type(FL_HORIZONTAL)
    time_slider_widget.step(1)
    if len(log_replay) > 0:
        time_slider_widget.bounds(0, len(log_replay)-1)
        time_slider_widget.value(args.replay_from_frame)
    else:
        time_slider_widget.bounds(0, 0)
        time_slider_widget.value(0)

    time_slider_widget.callback( lambda *args: time_slider_select(round(time_slider_widget.value())) )


status_widget = Fl_Output(0, H-H_status,
                          W, H_status)
status_widget.value('')

image_views = Fl_Group(0, 0, W, H-H_footers)
for i in range(Hgrid):
    x0 = 0

    for j in range(Wgrid):
        image_view_groups[icam] = \
            mrcam.Fl_Image_View_Group(x0,y0,
                                      w_image if j < Wgrid-1 else (W          -x0),
                                      h_image if i < Hgrid-1 else (H-H_footers-y0),
                                      camera          = cameras[icam],
                                      single_buffered = args.single_buffered,
                                      status_widget   = status_widget,
                                      features        = args.features,
                                      image_view_groups = \
                                      None if args.unlock_panzoom else image_view_groups)
        if image_view_groups[icam].camera is not None:
            image_view_groups[icam].set_up_image_capture(period         = None, # don't auto-recur. I do that myself, making sure ALL the cameras are processed
                                                         flip_x         = args.flip_x,
                                                         flip_y         = args.flip_y,

                                                         auto_update_image_widget = False,

                                                         image_callback = image_callback,
                                                         # These are all passed to image_callback()
                                                         extension      = "jpg" if args.jpg else "png",
                                                         logdir         = args.logdir,
                                                         icam           = icam)


        x0   += w_image
        icam += 1

        if icam == Ncameras:
            break
    if icam == Ncameras:
        break

    y0 += h_image
image_views.end()

window.resizable(image_views)
window.end()
window.show()

if args.replay is None:
    # request the initial frame; will recur in image_callback
    request_image_set()
else:
    time_slider_select(round(time_slider_widget.value()))

Fl.run()
